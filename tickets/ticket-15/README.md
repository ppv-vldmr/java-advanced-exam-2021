#####  private final Queue<T> tasksQueue;
очередь с заданиями, которые следует вычислить

#####   private final Set<T> computingSet;
мн-во заданий, которые прямо сейчас вычисляются

##### private final ConcurrentMap<T, Future<R>> cacheMap;
кеширующая мапа, запоминающая значения функции, чтобы несколько раз не вичислять одно и то же

#### основная идея: 
только один поток занимается вычислением функции от одного, конкретного значения

f.apply(1) // поток-1 начал вычисление
f.apply(1)  // поток-2 увидел, что поток-1 вычисляет и ждет ответа при помощи Future get()

##### shutdownAndAwaitTermination() 
можно спокойно рефакторить на свое усмотрение

#### implements AutoCloseable
для упрощения работы => если будете запускать из main(), то для корректной работы объявлять и инициализировать Memorizer лучше в блоке try-catch с ресурсами т.е. try(Memorizer<T1, T2> f = new Memorizer(Function)) { ...} 

#### synchronized блок
там отсеиваются лишние потоки (для того, чтобы вычислением функции занимался один поток, если запрос был в нескольких потоках, то остальные потоки будут ожидать выполнения первого, после чего возьмут значение из кеша)